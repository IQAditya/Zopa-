<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Redistribution on x + y = V</title>

  <link rel="stylesheet" href="style.css"/>
  <!-- Plotly CDN -->
  <script src="https://cdn.plot.ly/plotly-2.32.0.min.js" defer></script>
</head>
<body>
  <div class="app">

    <!-- LEFT: Chart -->
    <main class="left card">
      <header class="topbar">
        <h1>Redistribution on x + y = V</h1>
        <p class="subtitle">Feasible segment from P; axes auto‑scale to V + 10%</p>
      </header>

      <div id="chart" title="Tip: Drag the labels ‘P’ and ‘Q’ to move the points"></div>

      <!-- Triangle metrics -->
      <section class="card section" style="margin-top:12px;">
        <h3>Triangle metrics (P–R–Q)</h3>
        <div id="metrics" class="metrics"></div>
      </section>

      <section class="card section">
        <h3>Allocation (Q.x)</h3>
        <div class="slider-row">
          <input id="qx-slider" type="range" min="0" max="440" step="0.1" value="140">
          <output id="qx-slider-value">140.0</output>
        </div>
        <p class="hint">
          Feasible: <code>P.x ≤ Q.x ≤ P.x + Δ</code>, where
          <code>Δ = max(V − (P.x + P.y), 0)</code>. Axes: 0 → <code>V + 10%</code>.
        </p>
      </section>
    </main>

    <!-- RIGHT: Sidebar -->
    <aside class="right">

      <section class="card section">
        <h3>Points &amp; Values</h3>

        <div class="row">
          <label for="px-input" class="label">P.x</label>
          <input id="px-input" class="num" type="number" step="1" value="100.0">
          <button id="px-inc" class="btn plus" type="button">＋</button>
          <button id="px-dec" class="btn minus" type="button">－</button>
        </div>

        <div class="row">
          <label for="py-input" class="label">P.y</label>
          <input id="py-input" class="num" type="number" step="1" value="200.0">
          <button id="py-inc" class="btn plus" type="button">＋</button>
          <button id="py-dec" class="btn minus" type="button">－</button>
        </div>

        <div class="row">
          <label for="v-input" class="label">V (x+y)</label>
          <input id="v-input" class="num" type="number" step="1" value="400.0">
          <button id="v-inc" class="btn plus" type="button">＋</button>
          <button id="v-dec" class="btn minus" type="button">－</button>
        </div>

        <div class="row">
          <label for="qx-input" class="label">Q.x</label>
          <input id="qx-input" class="num" type="number" step="0.1" value="140.0">
          <button id="qx-inc" class="btn plus" type="button">＋</button>
          <button id="qx-dec" class="btn minus" type="button">－</button>
        </div>

        <div class="row">
          <label for="qy-input" class="label">Q.y</label>
          <input id="qy-input" class="num" type="number" step="0.1" value="260.0">
          <button id="qy-inc" class="btn plus" type="button">＋</button>
          <button id="qy-dec" class="btn minus" type="button">－</button>
        </div>

        <p class="hint">
          Q always satisfies <code>Q.x + Q.y = V</code>. While typing in Qx/Qy, we won’t snap to the feasible
          segment until you leave the field; then we clamp to <code>[P.x, P.x + Δ]</code>.
        </p>
      </section>

      <section class="card section">
        <h3>Visibility</h3>
        <label class="tog"><input id="show-p" type="checkbox" checked><span>Show P</span></label>
        <label class="tog"><input id="show-q" type="checkbox" checked><span>Show Q</span></label>
        <label class="tog"><input id="show-slope" type="checkbox" checked><span>Show Slope Line</span></label>

        <!-- NEW: Toggle lines/labels for K, H, Angle -->
        <div class="divider"></div>
        <label class="tog"><input id="show-base" type="checkbox" checked><span>Show Base K (PR)</span></label>
        <label class="tog"><input id="show-height" type="checkbox" checked><span>Show Height H (RQ)</span></label>
        <label class="tog"><input id="show-angle" type="checkbox" checked><span>Show Angle ∠RPQ</span></label>
      </section>

      <section class="card section">
        <h3>Actions</h3>
        <div class="actions">
          <button id="reset" class="btn ghost" type="button">Reset</button>
          <button id="snap-p" class="btn ghost" type="button">Snap P → line</button>
          <button id="center" class="btn ghost" type="button">Center</button>
        </div>
      </section>
    </aside>
  </div>

  <!-- Logic -->
  <script>
  // Ensure Plotly is loaded before running the app
  window.addEventListener('DOMContentLoaded', () => {
    const onReady = () => (window.Plotly ? initApp() : setTimeout(onReady, 30));
    onReady();
  });

  function initApp(){
    /* ---------------- Constants / Globals ---------------- */
    const X_MIN = 0.0, Y_MIN = 0.0;
    let   AXIS_MAX = 440.0;            // dynamic = V + 10%
    const STEP_Q = 0.1;                // button step for Qx/Qy
    const chart = document.getElementById('chart');

    // Plot state flags
    let plotReady = false;   // have we called newPlot?
    let eventsBound = false; // have we bound plotly events?

    /* ---------------- DOM refs ---------------- */
    const $ = id => document.getElementById(id);
    const pxInput = $('px-input'), pyInput = $('py-input'), vInput = $('v-input');
    const qxInput = $('qx-input'), qyInput = $('qy-input');
    const qxSlider = $('qx-slider'), qxSliderValue = $('qx-slider-value');
    const showP = $('show-p'), showQ = $('show-q'), showSlope = $('show-slope');
    const showBase = $('show-base'), showHeight = $('show-height'), showAngle = $('show-angle');
    const metricsBox = $('metrics');

    // Track manual typing state so we don't clamp while typing
    let typingQx = false, typingQy = false;

    /* ---------------- Math helpers ---------------- */
    const clamp = (v, lo, hi) => Math.max(lo, Math.min(hi, v));
    const deg = rad => rad * 180 / Math.PI;
    const delta = (Px, Py, V) => Math.max(0, V - (Px + Py));
    function feasibleQxBounds(Px, Py, V){
      const d = delta(Px, Py, V);
      let lo = clamp(Px, X_MIN, AXIS_MAX);
      let hi = clamp(Px + d, X_MIN, AXIS_MAX);
      if (hi < lo) hi = lo;
      return [lo, hi, d];
    }

    /* ---------------- Metrics helper ---------------- */
    function updateMetrics(Px, Py, Qx, Qy){
      // R is vertical projection of Q onto y = P.y
      const Rx = Qx, Ry = Py;
      const K = Math.abs(Rx - Px);     // base |PR|
      const H = Math.abs(Qy - Ry);     // height |RQ|
      const theta = deg(Math.atan2(H, K || 0));  // angle at P (RPQ)

      metricsBox.innerHTML = `
        <span class="badge">P = (${Px.toFixed(1)}, ${Py.toFixed(1)})</span>
        <span class="badge">Q = (${Qx.toFixed(1)}, ${Qy.toFixed(1)})</span>
        <span class="badge">R = (${Rx.toFixed(1)}, ${Ry.toFixed(1)})</span>
        <span class="badge">K (base PR) = ${K.toFixed(1)}</span>
        <span class="badge">H (height RQ) = ${H.toFixed(1)}</span>
        <span class="badge">∠RPQ = ${theta.toFixed(2)}°</span>
      `;
      return {K, H, Rx, Ry, theta};
    }

    /* ---------------- Plot builder ---------------- */
    function renderPlot(traces, layout) {
      const config = {displayModeBar:false};
      if (!plotReady) {
        Plotly.newPlot(chart, traces, layout, config).then(()=>{
          plotReady = true;
          if (!eventsBound) bindPlotEvents();
        }).catch(err=>console.error('Plotly.newPlot error:', err));
      } else {
        Plotly.react(chart, traces, layout, config).catch(err=>console.error('Plotly.react error:', err));
      }
    }

    function buildFigure(Px, Py, V, Qx, visP, visQ, visSlope, visBase, visHeight, visAngle){
      const Qy = V - Qx;  // Q must satisfy the line
      const {K, H, Rx, Ry, theta} = updateMetrics(Px, Py, Qx, Qy);

      // Sample slope inside the visible box
      const xs = Array.from({length:600}, (_,i)=> X_MIN + (AXIS_MAX - X_MIN)*i/599);
      const ys = xs.map(x => V - x);

      const traces = [];

      // Slope line
      if (visSlope){
        traces.push({ x: xs, y: ys, mode: 'lines', name: 'x + y = V',
                      line: {color:'#e11d48', width:3} });
      }

      // P guides
      if (visP){
        traces.push({ x:[Px,Px], y:[Y_MIN,Py], mode:'lines', showlegend:false,
                      line:{color:'#9ca3af', dash:'dash'} });
        traces.push({ x:[X_MIN,Px], y:[Py,Py], mode:'lines', showlegend:false,
                      line:{color:'#9ca3af', dash:'dash'} });
      }

      // Q guides
      if (visQ){
        traces.push({ x:[Qx,Qx], y:[Y_MIN,Qy], mode:'lines', showlegend:false,
                      line:{color:'#60a5fa', dash:'dash'} });
        traces.push({ x:[X_MIN,Qx], y:[Qy,Qy], mode:'lines', showlegend:false,
                      line:{color:'#60a5fa', dash:'dash'} });
      }

      // Triangle edges (conditional)
      if (visBase){
        traces.push({ x:[Px, Rx], y:[Py, Ry], mode:'lines', name:'Base K (PR)',
                      line:{color:'#f59e0b', dash:'dot', width:3} });
        // Label for K near segment
        const offK = 0.015 * AXIS_MAX;
        traces.push({ x:[(Px+Rx)/2], y:[Py + offK], mode:'text', showlegend:false,
                      text:[`K = ${K.toFixed(1)}`], textfont:{color:'#b45309'}, textposition:'top center' });
      }
      if (visHeight){
        traces.push({ x:[Rx, Qx], y:[Ry, Qy], mode:'lines', name:'Height H (RQ)',
                      line:{color:'#059669', dash:'dot', width:3} });
        // Label for H near segment
        const offH = 0.015 * AXIS_MAX;
        traces.push({ x:[Rx + offH], y:[(Ry+Qy)/2], mode:'text', showlegend:false,
                      text:[`H = ${H.toFixed(1)}`], textfont:{color:'#065f46'}, textposition:'middle left' });
      }
      // Always draw slant PQ (kept as before)
      traces.push({ x:[Px, Qx], y:[Py, Qy], mode:'lines', name:'PQ',
                    line:{color:'#059669', dash:'dash', width:3} });

      // Angle label at P (conditional)
      if (visAngle){
        const offA = 0.015 * AXIS_MAX;
        traces.push({ x:[Px + offA], y:[Py + offA], mode:'text', showlegend:false,
                      text:[`∠RPQ = ${theta.toFixed(2)}°`], textfont:{color:'#111827'}, textposition:'top left' });
      }

      // Extremes on the slope using Δ (these always show; unchanged)
      const d = Math.max(0, V - (Px + Py));
      const qxX = clamp(Px + d, X_MIN, AXIS_MAX);
      const qyX = clamp(V - qxX, Y_MIN, AXIS_MAX);
      traces.push({ x:[qxX], y:[qyX], mode:'markers', name:'All extra → X',
                    marker:{symbol:'square-open', color:'#059669', size:11} });

      const qyY = clamp(Py + d, Y_MIN, AXIS_MAX);
      const qxY = clamp(V - qyY, X_MIN, AXIS_MAX);
      traces.push({ x:[qxY], y:[qyY], mode:'markers', name:'All extra → Y',
                    marker:{symbol:'square-open', color:'#7c3aed', size:11} });

      // P and Q markers
      if (visP){
        traces.push({
          x:[Px], y:[Py], mode:'markers', name:'P(start)',
          marker:{color:'#111827', size:11, line:{width:1, color:'#111827'}}
        });
      }
      if (visQ){
        traces.push({
          x:[Qx], y:[Qy], mode:'markers', name:'Q (allocation)',
          marker:{color:'white', size:10, line:{width:2, color:'#2563eb'}}
        });
        // R marker
        traces.push({
          x:[Rx], y:[Ry], mode:'markers+text', name:'R',
          marker:{color:'#ec4899', size:8}, text:['R'], textposition:'top center',
          textfont:{color:'#ec4899'}
        });
      }

      // Draggable annotations: P (0) and Q (1)
      const annotations = [
        { x: Px, y: Py, xref:'x', yref:'y', text:'P', showarrow:false,
          xanchor:'left', yanchor:'bottom', font:{color:'#111827', size:12} },
        { x: Qx, y: Qy, xref:'x', yref:'y', text:'Q', showarrow:false,
          xanchor:'left', yanchor:'bottom', font:{color:'#2563eb', size:12} },
      ];

      const layout = {
        margin:{l:40,r:20,t:30,b:40},
        height:520, plot_bgcolor:'#ffffff', paper_bgcolor:'#ffffff',
        legend:{bgcolor:'white', bordercolor:'#e5e7eb', borderwidth:1,
                orientation:'h', yanchor:'bottom', y:1.02, x:0},
        xaxis:{range:[X_MIN, AXIS_MAX], gridcolor:'#e5e7eb', title:'x', zeroline:false, fixedrange:true},
        yaxis:{range:[Y_MIN, AXIS_MAX], gridcolor:'#e5e7eb', title:'y', zeroline:false, fixedrange:true},
        dragmode:false,
        editable:true,   /* <-- enables dragging annotations (‘P’, ‘Q’) */
        annotations
      };

      renderPlot(traces, layout);
    }

    /* ---------------- State helpers ---------------- */
    function getState(){
      return {
        Px: parseFloat(pxInput.value || '0'),
        Py: parseFloat(pyInput.value || '0'),
        V:  parseFloat(vInput.value  || '0'),
        Qx: parseFloat(qxInput.value || '0'),
        Qy: parseFloat(qyInput.value || '0'),
        visP: showP.checked, visQ: showQ.checked, visSlope: showSlope.checked,
        visBase: showBase.checked, visHeight: showHeight.checked, visAngle: showAngle.checked
      };
    }
    function syncQxRail(Px, Py, V, {forceClamp} = {forceClamp:true}){
      const [min, max] = feasibleQxBounds(Px, Py, V);
      qxSlider.min = String(min);
      qxSlider.max = String(max);
      if (forceClamp){
        const cur = parseFloat(qxSlider.value);
        const clampVal = Math.max(min, Math.min(max, cur));
        if (clampVal !== cur) qxSlider.value = clampVal;
      }
    }

    /* ---------------- Core refresh ---------------- */
    function refresh(){
      let {Px, Py, V, Qx, Qy, visP, visQ, visSlope, visBase, visHeight, visAngle} = getState();

      // 1) Dynamic axes based on V
      AXIS_MAX = Math.max(0, 1.1 * V);
      qxSlider.max = AXIS_MAX;

      // 2) Clamp P in visible box
      Px = Math.max(X_MIN, Math.min(AXIS_MAX, Px));
      Py = Math.max(Y_MIN, Math.min(AXIS_MAX, Py));

      // 3) Enforce Qx + Qy = V with typing flags
      if (typingQy){
        Qy = parseFloat(qyInput.value || '0');
        Qx = V - Qy;
        qxInput.value = Qx.toFixed(1);
      } else if (typingQx){
        Qx = parseFloat(qxInput.value || '0');
        Qy = V - Qx;
        qyInput.value = Qy.toFixed(1);
      } else {
        Qx = parseFloat(qxInput.value || '0');
        Qy = V - Qx;
        qyInput.value = Qy.toFixed(1);
      }

      // 4) Feasible rail
      syncQxRail(Px, Py, V, {forceClamp: !(typingQx || typingQy)});

      if (!(typingQx || typingQy)){
        const [min, max] = feasibleQxBounds(Px, Py, V);
        Qx = Math.max(min, Math.min(max, Qx));
        Qy = V - Qx;

        qxInput.value = Qx.toFixed(1);
        qyInput.value = Qy.toFixed(1);
        qxSlider.value = Qx;
        qxSliderValue.textContent = Qx.toFixed(1);
      } else {
        qxSliderValue.textContent = (parseFloat(qxInput.value || '0')).toFixed(1);
      }

      // 5) Draw (also updates metrics)
      buildFigure(Px, Py, V, parseFloat(qxInput.value || '0'),
                  visP, visQ, visSlope, visBase, visHeight, visAngle);
    }

    /* ---------------- Event binding for dragging ---------------- */
    function bindPlotEvents(){
      if (eventsBound) return;
      const relayoutHandler = (e)=>{
        if (!e) return;
        const has = k => Object.prototype.hasOwnProperty.call(e, k);
        const V = parseFloat(vInput.value || '0');

        // P moved (drag ‘P’ label)
        if (has('annotations[0].x') || has('annotations[0].y')) {
          const newPx = has('annotations[0].x') ? e['annotations[0].x'] : parseFloat(pxInput.value||'0');
          const newPy = has('annotations[0].y') ? e['annotations[0].y'] : parseFloat(pyInput.value||'0');
          AXIS_MAX = Math.max(0, 1.1 * V);
          pxInput.value = Math.max(0, Math.min(AXIS_MAX, newPx)).toFixed(1);
          pyInput.value = Math.max(0, Math.min(AXIS_MAX, newPy)).toFixed(1);
          typingQx = typingQy = false;
          refresh();
          return;
        }

        // Q moved (drag ‘Q’ label) – keep on feasible rail
        if (has('annotations[1].x') || has('annotations[1].y')) {
          let qx = has('annotations[1].x') ? e['annotations[1].x'] : parseFloat(qxInput.value||'0');
          const Px = parseFloat(pxInput.value||'0');
          const Py = parseFloat(pyInput.value||'0');
          const [min, max] = feasibleQxBounds(Px, Py, V);
          qx = Math.max(min, Math.min(max, qx));
          qxInput.value = qx.toFixed(1);
          qyInput.value = (V - qx).toFixed(1);
          qxSlider.value = qx;
          qxSliderValue.textContent = qx.toFixed(1);
          typingQx = typingQy = false;
          refresh();
          return;
        }
      };

      chart.on('plotly_relayout', relayoutHandler);
      chart.on('plotly_relayouting', relayoutHandler);
      eventsBound = true;
    }

    /* ---------------- Wiring ---------------- */
    // Focus/blur to control typing flags
    qxInput.addEventListener('focus', ()=>{ typingQx = true; });
    qxInput.addEventListener('blur',  ()=>{ typingQx = false; refresh(); });
    qyInput.addEventListener('focus', ()=>{ typingQy = true; });
    qyInput.addEventListener('blur',  ()=>{ typingQy = false; refresh(); });

    // Inputs (live typing)
    [pxInput, pyInput, vInput, qxInput, qyInput].forEach(el=>{
      el.addEventListener('change', refresh);
      el.addEventListener('input', ()=>{
        if (el === qxInput) qxSliderValue.textContent = (parseFloat(qxInput.value || '0')).toFixed(1);
        refresh();
      });
    });

    // Slider
    qxSlider.addEventListener('input', ()=>{
      if (typingQx || typingQy) return;
      qxInput.value = parseFloat(qxSlider.value).toFixed(1);
      qxSliderValue.textContent = parseFloat(qxSlider.value).toFixed(1);
      refresh();
    });

    // Visibility
    [showP, showQ, showSlope, showBase, showHeight, showAngle]
      .forEach(cb => cb.addEventListener('change', refresh));

    // Buttons (+/−)
    Object.entries({
      'px-inc': +1, 'px-dec': -1,
      'py-inc': +1, 'py-dec': -1,
      'v-inc':  +1, 'v-dec':  -1,
      'qx-inc': +STEP_Q, 'qx-dec': -STEP_Q,
      'qy-inc': +STEP_Q, 'qy-dec': -STEP_Q,
    }).forEach(([id, step])=>{
      document.getElementById(id).addEventListener('click', ()=>{
        const key = id.split('-')[0];
        if (key === 'qx'){
          typingQx = true;
          const cur = parseFloat(qxInput.value || '0');
          qxInput.value = (cur + step).toFixed(1);
          refresh();
          typingQx = false;
        } else if (key === 'qy'){
          typingQy = true;
          const cur = parseFloat(qyInput.value || '0');
          qyInput.value = (cur + step).toFixed(1);
          refresh();
          typingQy = false;
        } else if (key === 'v'){
          const cur = parseFloat(vInput.value || '0');
          vInput.value = (cur + step).toFixed(1);
          refresh();
        } else {
          const input = document.getElementById(key + '-input');
          const cur = parseFloat(input.value || '0');
          input.value = (cur + step).toFixed(1);
          refresh();
        }
      });
    });

    // Actions
    document.getElementById('reset').addEventListener('click', ()=>{
      pxInput.value='100.0'; pyInput.value='200.0'; vInput.value='400.0';
      qxInput.value='140.0'; qyInput.value='260.0';
      showP.checked=true; showQ.checked=true; showSlope.checked=true;
      showBase.checked=true; showHeight.checked=true; showAngle.checked=true;
      qxSlider.value='140.0'; qxSliderValue.textContent='140.0';
      typingQx = typingQy = false;
      refresh();
    });
    document.getElementById('snap-p').addEventListener('click', ()=>{
      const V = parseFloat(vInput.value || '0');
      const Px = parseFloat(pxInput.value || '0');
      pyInput.value = (V - Px).toFixed(1);
      refresh();
    });
    document.getElementById('center').addEventListener('click', refresh);

    // Initial draw
    refresh();
  }
  </script>
</body>
</html>
